# -*- coding: utf-8 -*-
import re
from collections.abc import Callable
from typing import TypeAlias

import sqlparse
from langchain_core.messages import AIMessage, ToolMessage
from pydantic import BaseModel, Field

Handler: TypeAlias = Callable[[dict], tuple[str, str] | None]

# SQLAgent nodes
LIST_DATASETS = "list_datasets"
CALL_SELECT_DATASETS = "call_select_datasets"
TABLES_INFO = "tables_info"
QUERY_AGENT = "query_agent"
GET_ANSWER = "get_answer"
SQL_TOOLS = "tools"


class Step(BaseModel):
    label: str = Field(
        description="Short description of the action taken by the agent at this step"
    )
    content: str = Field(description="Detailed output generated by the agent for this step")


# ============================== Helper Functions ==============================
def _format_sql(sql: str, reindent: bool = True, keyword_case: str = "upper") -> str:
    return sqlparse.format(sql=sql, reindent=reindent, keyword_case=keyword_case)


def _format_table_schemas(text: str) -> str:
    def replacer(match: re.Match):
        header = match.group(1)
        schema = match.group(2).strip()
        footer = match.group(3)
        return f"{header}```sql\n{schema}\n```{footer}"

    return re.sub(
        pattern=r"(### Schema:\s*)(.*?)(\s*### Column Details:)",
        repl=replacer,
        string=text,
        flags=re.DOTALL,
    )


# ========================== SQLAgent Chunk Handlers ==========================
def _handle_list_datasets(chunk: dict) -> tuple[str, str]:
    message: ToolMessage = chunk[LIST_DATASETS]["messages"][0]

    label = "Selecionando conjuntos de dados..."
    content = (
        "##### Selecionando conjuntos de dados:\n\n"
        + message.content.replace("### ", "").replace("# ", "##### ")
    ).strip() + "\n---\n"

    return label, content


def _handle_call_select_datasets(chunk: dict) -> tuple[str, str]:
    message: AIMessage = chunk[CALL_SELECT_DATASETS]["messages"][-1]
    names: list[str] = []

    for tool_call in message.tool_calls:
        dataset_names: str = tool_call["args"].get("dataset_names")
        if dataset_names:
            names.extend(dataset_names.split(","))

    bolded_names = [f"**{name.strip()}**" for name in names]

    label = "Selecionando tabelas..."
    content = "##### Selecionando tabelas para os conjuntos de dados:"

    if not bolded_names:
        return label, content

    content += "\n - ##### " + "\n - ##### ".join(bolded_names).strip()

    return label, content


def _handle_tables_info(chunk: dict) -> tuple[str, str]:
    messages: list[ToolMessage] = chunk[TABLES_INFO]["messages"]

    formatted_tables_info = []

    for message in messages:
        if message.status == "error":
            info = ":red[**Erro ao selecionar tabelas. Tentando novamente...**]"
        else:
            info = _format_table_schemas(message.content)
        formatted_tables_info.append(info)

    label = "Selecionando tabelas..."
    content = (
        "\n\n".join(formatted_tables_info).replace("### ", "").replace("# ", "##### ").strip()
        + "\n\n---\n"
    )

    return label, content


def _handle_query_agent(chunk: dict) -> tuple[str, str] | None:
    message: AIMessage = chunk[QUERY_AGENT]["messages"][0]

    if not message.tool_calls:
        return None

    content_parts = []

    for tool_call in message.tool_calls:
        tool_name = tool_call["name"]

        if tool_name == "sql_query_check":
            query = tool_call["args"].get("query")
            label = "Verificando consulta..."
            if query:
                part = f"##### Verificando consulta:\n```sql\n{_format_sql(query)}\n```"
            else:
                part = "##### Verificando consulta:\n:red[**Erro na chamada da ferramenta**]"
            content_parts.append(part)

        elif tool_name == "sql_query":
            query = tool_call["args"].get("query")
            label = "Executando consulta..."
            if query:
                part = f"##### Executando consulta:\n```sql\n{_format_sql(query)}\n```"
            else:
                part = "##### Executando consulta:\n:red[**Erro na chamada da ferramenta**]"
            content_parts.append(part)

    content = "\n".join(content_parts) + "\n\n---\n"

    return label, content


def _handle_sql_tools(chunk: dict) -> tuple[str, str] | None:
    message: ToolMessage = chunk[SQL_TOOLS]["messages"][0]

    if message.status == "success":
        return None

    if message.name == "sql_query_check":
        label = "Verificando consulta..."
        content = ":red[**Erro na verificação da consulta**]\n\n---\n"
    elif message.name == "sql_query":
        label = "Executando consulta..."
        content = ":red[**Erro na execução da consulta**]\n\n---\n"

    return label, content


def _handle_get_answer(chunk: dict) -> tuple[str, str]:
    final_answer = chunk[GET_ANSWER]["final_answer"]
    label = "Gerando resposta..."
    content = f"##### Resposta final:\n\n{final_answer}".strip()
    return label, content


# ========= Mapping of SQLAgent chunks to their corresponding handlers =========
SQL_AGENT_HANDLERS: dict[str, Handler] = {
    LIST_DATASETS: _handle_list_datasets,
    CALL_SELECT_DATASETS: _handle_call_select_datasets,
    TABLES_INFO: _handle_tables_info,
    QUERY_AGENT: _handle_query_agent,
    SQL_TOOLS: _handle_sql_tools,
    GET_ANSWER: _handle_get_answer,
}


def process_chunk(chunk: dict) -> tuple[str, str] | None:
    """Process a single chunk from the stream by dispatching it to the correct handler.

    Args:
        chunk (dict): A chunk from the stream.

    Returns:
        tuple[str, str] | None: The processed results if a handler was found. `None` otherwise.
    """
    for key, handler in SQL_AGENT_HANDLERS.items():
        if key in chunk:
            return handler(chunk)
    return None
