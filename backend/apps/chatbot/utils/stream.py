# -*- coding: utf-8 -*-
import re
from collections.abc import Callable
from typing import TypeAlias

import sqlparse
from langchain_core.messages import AIMessage, ToolMessage
from pydantic import BaseModel, Field

Handler: TypeAlias = Callable[[dict], tuple[str, str] | None]

# SQLAgent nodes
LIST_DATASETS = "list_datasets"
CALL_SELECT_DATASETS = "call_select_datasets"
TABLES_INFO = "tables_info"
QUERY_AGENT = "query_agent"
GET_ANSWER = "get_answer"
SQL_TOOLS = "tools"


class StepContent(BaseModel):
    title: str | None = Field(default=None, description="A title to be displayed in the UI")
    body: str = Field(description="Content to be displayed in the UI")


class Step(BaseModel):
    label: str = Field(
        description="Short description of the action taken by the agent at this step"
    )
    content: list[StepContent] = Field(
        description="Detailed outputs generated by the agent for this step"
    )


# ============================== Helper Functions ==============================
def _format_sql(sql: str, reindent: bool = True, keyword_case: str = "upper") -> str:
    return sqlparse.format(sql=sql, reindent=reindent, keyword_case=keyword_case)


def _format_datasets_info(text: str) -> str:
    matches = re.findall(
        pattern=r"^# (.*?)\s+### Description:\s+(.*?)### Tables:",
        string=text,
        flags=re.MULTILINE | re.DOTALL,
    )

    parts = []

    for title, description in matches:
        parts.append(f"##### {title.strip()}\n\n{description.strip()}")

    return "\n\n".join(parts)


def _format_tables_info(text: str) -> str:
    matches = re.findall(
        pattern=r"^# (.*?)\s+### Description:\s+(.*?)### Schema:",
        string=text,
        flags=re.MULTILINE | re.DOTALL,
    )

    parts = []

    for title, description in matches:
        parts.append(f"##### {title}\n\n{description}")

    return "\n\n".join(parts)


# ========================== SQLAgent Chunk Handlers ==========================
def _handle_list_datasets(chunk: dict) -> Step:
    message: ToolMessage = chunk[LIST_DATASETS]["messages"][0]

    label = "Selecionando conjuntos de dados..."

    content = StepContent(
        title="Buscando Conjuntos de Dados:", body=_format_datasets_info(message.content)
    )

    return Step(label=label, content=[content])


def _handle_call_select_datasets(chunk: dict) -> Step:
    message: AIMessage = chunk[CALL_SELECT_DATASETS]["messages"][-1]
    names: list[str] = []

    for tool_call in message.tool_calls:
        dataset_names: str = tool_call["args"].get("dataset_names")
        if dataset_names:
            names.extend(dataset_names.split(","))

    bolded_names = [f"**{name.strip()}**" for name in names]

    label = "Selecionando conjuntos de dados..."

    if not bolded_names:
        body = ""

    body = "Conjuntos de dados selecionandos:\n" "- " + "\n- ".join(bolded_names)

    content = StepContent(title="Selecionando Conjuntos de Dados:", body=body)

    return Step(label=label, content=[content])


def _handle_tables_info(chunk: dict) -> Step:
    messages: list[ToolMessage] = chunk[TABLES_INFO]["messages"]

    formatted_tables_info = []

    for message in messages:
        if message.status == "error":
            formatted_tables_info.append(
                ":red[**Erro ao selecionar tabelas. Tentando novamente...**]"
            )
        else:
            formatted_tables_info.append(_format_tables_info(message.content))

    label = "Selecionando tabelas..."

    content = StepContent(
        title="Selecionando Tabelas:", body="\n\n---\n\n".join(formatted_tables_info)
    )

    return Step(label=label, content=[content])


def _handle_query_agent(chunk: dict) -> Step | None:
    message: AIMessage = chunk[QUERY_AGENT]["messages"][0]

    if not message.tool_calls:
        return None

    content_parts = []

    for tool_call in message.tool_calls:
        tool_name = tool_call["name"]

        if tool_name == "sql_query_check":
            query = tool_call["args"].get("query")
            label = "Verificando consulta..."
            if query:
                body = f"```sql\n{_format_sql(query)}\n```"
            else:
                body = "red[**Erro na chamada da ferramenta**]"
            part = StepContent(title="Verificando Consulta:", body=body)
            content_parts.append(part)

        elif tool_name == "sql_query_exec":
            query = tool_call["args"].get("query")
            label = "Executando consulta..."
            if query:
                body = f"```sql\n{_format_sql(query)}\n```"
            else:
                body = "red[**Erro na chamada da ferramenta**]"
            part = StepContent(title="Executando Consulta:", body=body)
            content_parts.append(part)

    if len(content_parts) > 1:
        label = "Consultando banco de dados..."

    return Step(label=label, content=content_parts)


def _handle_sql_tools(chunk: dict) -> Step | None:
    updates = chunk[SQL_TOOLS]

    # single tool call
    if isinstance(updates, dict):
        messages: list[ToolMessage] = updates["messages"]
    # multiple parallel tool calls
    elif isinstance(updates, list):
        messages: list[ToolMessage] = [
            update["messages"][0] for update in updates if "messages" in update
        ]

    content_parts = []

    for message in messages:
        if message.status == "success":
            continue

        if message.name == "sql_query_check":
            label = "Verificando consulta..."
            part = StepContent(
                title="Verificando Consulta...", body=":red[**Erro na verificação da consulta**]"
            )
        elif message.name == "sql_query_exec":
            label = "Executando consulta..."
            part = StepContent(
                title="Executando Consulta...", body=":red[**Erro na execução da consulta**]"
            )

        content_parts.append(part)

    if content_parts:
        if len(content_parts) > 1:
            label = "Consultando banco de dados..."
        return Step(label=label, content=content_parts)

    return None


def _handle_get_answer(chunk: dict) -> Step:
    final_answer = chunk[GET_ANSWER]["final_answer"]
    label = "Gerando resposta..."
    content = StepContent(title="Resposta Final:", body=final_answer)
    return Step(label=label, content=[content])


# ========= Mapping of SQLAgent chunks to their corresponding handlers =========
SQL_AGENT_HANDLERS: dict[str, Handler] = {
    LIST_DATASETS: _handle_list_datasets,
    CALL_SELECT_DATASETS: _handle_call_select_datasets,
    TABLES_INFO: _handle_tables_info,
    QUERY_AGENT: _handle_query_agent,
    SQL_TOOLS: _handle_sql_tools,
    GET_ANSWER: _handle_get_answer,
}


def process_chunk(chunk: dict) -> Step | None:
    """Process a single chunk from the stream by dispatching it to the correct handler.

    Args:
        chunk (dict): A chunk from the stream.

    Returns:
        Step | None: The processed results if a handler was found. `None` otherwise.
    """
    for key, handler in SQL_AGENT_HANDLERS.items():
        if key in chunk:
            return handler(chunk)
    return None
